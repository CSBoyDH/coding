#
# 平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。
#
# 如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。
#
# 请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。
#
#
# 输入描述:
# 输入包括五行。
# 第一行包括一个整数n(2 <= n <= 50), 表示矩形的个数。
# 第二行包括n个整数x1[i](-10^9 <= x1[i] <= 10^9),表示左下角的横坐标。
# 第三行包括n个整数y1[i](-10^9 <= y1[i] <= 10^9),表示左下角的纵坐标。
# 第四行包括n个整数x2[i](-10^9 <= x2[i] <= 10^9),表示右上角的横坐标。
# 第五行包括n个整数y2[i](-10^9 <= y2[i] <= 10^9),表示右上角的纵坐标。
#
#
# 输出描述:
# 输出一个正整数, 表示最多的地方有多少个矩形相互重叠,如果矩形都不互相重叠,输出1。
# 示例1
# 输入
# 2
# 0 90
# 0 90
# 100 200
# 100 200
# 输出
# 2
# 使用暴力求解，遍历实现；
# 遍历每个点在多少个矩形中出现，只要出现说明该点的矩形就会出现重叠。
# 求出现次数最多的点，返回其次数即为重叠的个数。
# 暴力美学。
N  = int(input())
x1 = list(map(int,input().split()))
y1 =list(map(int,input().split()))
x2 = list(map(int,input().split()))
y2 = list(map(int,input().split()))

a = x1+x2
b = y1+y2
ans = 0
for x in range(len(a)):
    for y  in range(len(b)):
        cnt = 0
        for i in range(N):
            if x1[i]<=a[x] and y1[i]<=b[y] and x2[i] > a[x] and y2[i] > b[y]:
                cnt+=1
            ans = max(ans,cnt)
print(ans)